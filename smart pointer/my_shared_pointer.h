/** * Custom implementation of shared_pointer */#include <iostream>#ifndef SMART_POINTER_MY_SHARED_POINTER_H#define SMART_POINTER_MY_SHARED_POINTER_Htemplate <typename T> class my_shared_pointer {private:    T* ptr;    /**     * Deletes ptr and refCount objects     */    void freeMem();//protected:    int* refCount;public:    /**     * Constructs nullptr of type T*     */    //my_shared_pointer();    /**     * Constructs my_shared_pointer with pointer pointing to obj     * @param obj - object to point to     */    my_shared_pointer(T obj);    /**     * Copies this shared pointer to p, increments ref count     * @param p - shared_pointer object to copy into     */    my_shared_pointer(const my_shared_pointer &p);    my_shared_pointer(my_shared_pointer &p);    /**     * Deconstructor     */    ~my_shared_pointer();    /**     * Reassigns this ptr to other. Decrements refCount and deletes if needed;     * @param other - other shared_pointer to convert to     * @return converted shared_pointer reference     */    my_shared_pointer& operator=(const my_shared_pointer<T>& other);    /**     * Dereference internal pointer     * @return - reference to object internal pointer points to     */    my_shared_pointer& operator*();    /**     * Returns internal pointer     * @return pointer wrapped by this shared_pointer     */    T* get();    /**     * Returns the number of my_shared_ptr objects referring to the same managed object     * @return total my_shared_ptr objects pointing to same object     */     int use_count();};template <typename T> my_shared_pointer<T> make_my_shared(T obj);template <typename T> void my_shared_pointer<T>::freeMem() {    delete ptr;    delete refCount;}template <typename T> my_shared_pointer<T> make_my_shared(T obj) {    return my_shared_pointer<T>(obj);}//template <typename T> my_shared_pointer<T>::my_shared_pointer() {//    ptr = nullptr;//    refCount = new int(0);//    *refCount = 0;//}template <typename T> my_shared_pointer<T>::my_shared_pointer(T obj) {    ptr = new T(obj);    refCount = new int(0);    (*refCount)++;}template <typename T> my_shared_pointer<T>::my_shared_pointer(const my_shared_pointer &p) { // why need const??    ptr = p.ptr;    refCount = p.refCount;    (*refCount)++;    std::cout<<"const";}template <typename T> my_shared_pointer<T>::my_shared_pointer(my_shared_pointer &p) { // why need const??    ptr = p.ptr;    refCount = p.refCount;    (*refCount)++;    std::cout<<"not const";}template <typename T> my_shared_pointer<T>::~my_shared_pointer<T>() {    (*refCount)--;    if(*refCount==0)        freeMem();}template <typename T> my_shared_pointer<T> &my_shared_pointer<T>::operator=(const my_shared_pointer<T> &other) {    *this->refCount-=1;    if(*refCount==0)        freeMem();    this->ptr = other.ptr;    this->refCount = other.refCount;    *this->refCount+=1;    return *this;}template <typename T> my_shared_pointer<T> &my_shared_pointer<T>::operator*() {    return *ptr;}template <typename T> T* my_shared_pointer<T>::get() {    return ptr;}template <typename T> int my_shared_pointer<T>::use_count() {    return *refCount;}#endif //SMART_POINTER_MY_SHARED_POINTER_H